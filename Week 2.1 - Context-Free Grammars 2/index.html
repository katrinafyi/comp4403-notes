<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    
    <title>Week 2.1 - Context-Free Grammars 2</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/light.min.css">
    <!--<link rel="stylesheet" href="https://unpkg.com/mvp.css">-->
    <!--<link rel="stylesheet" href="https://latex.now.sh/style.css">-->
    <style>
        code{white-space: pre-wrap;}
        span.smallcaps{font-variant: small-caps;}
        span.underline{text-decoration: underline;}
        div.column{display: inline-block; vertical-align: top; width: 50%;}
        .katex { font-size: 1.1em; }
    </style>
    <!--<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
    <script>document.addEventListener("DOMContentLoaded", function () {
    var mathElements = document.getElementsByClassName("math");
    var macros = [];
    /*
    const BATCH_SIZE = 100;
    var i = 0;
    while (i < mathElements.length) {
      const start = i;
      setTimeout(() => {
        for (var j = 0; j < BATCH_SIZE; j++) {
          const i = start + j;
          if (i >= mathElements.length) break;

          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }, 0);
      i += BATCH_SIZE;
    }
    */
    
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
      katex.render(texText.data, mathElements[i], {
        displayMode: mathElements[i].classList.contains('display'),
        throwOnError: false,
        macros: macros,
        fleqn: false
      });
    }}
    
    });
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <h1>Week 2.1 - Context-Free Grammars 2</h1>

    <!--
<header id="title-block-header">
<h1 class="title">Lecture 3 — Context-Free Grammars 2</h1>
</header>
-->


<h1 id="lecture-3-context-free-grammars-2">Lecture 3 — Context-Free Grammars 2</h1>
<p>Consider a grammar: <span class="math display">
\begin{aligned}
L &amp;\to LL \\ 
L &amp;\to ``x&quot; \\ 
L &amp;\to \epsilon
\end{aligned}
</span> The language of this is <span class="math display">
\mathcal L(G) = \{\epsilon, x, xx, xxx, \ldots\}.
</span> This is ambiguous because the expansion of <span class="math inline">\epsilon</span> could occur anywhere in the string. For example, <span class="math inline">x</span> has parse trees <span class="math inline">L(x)</span>, <span class="math inline">L(L(x), L(\epsilon))</span>, and more.</p>
<p>To make this unambiguous, we can force the literal <span class="math inline">x</span> to occur at either the start or end of the production. That is, <span class="math display">
\begin{aligned}
L &amp;\to L\ ``x&quot; \\ 
L &amp;\to \epsilon
\end{aligned}
</span> It should be obvious that <span class="math inline">\mathcal L(G)</span> is unchanged from before, but the grammar is now unambiguous.</p>
<h2 id="statement-sequences">Statement sequences</h2>
<p>Consider a sequence of one or more statements separated by semicolons. A possible grammar is <span class="math display">
\begin{aligned}
SS &amp;\to S \\ 
SS &amp;\to SS\ ``;&quot;\ S
\end{aligned}
</span> Subtly different, consider a sequence of one or more statements <em>terminated</em> by semicolons. <span class="math display">
\begin{aligned}
SS &amp;\to S\ ``;&quot; SS\\
SS &amp;\to SS\ S\ ``;&quot;
\end{aligned}
</span></p>
<p>Some common idioms are things prefixed or suffixed by other things (left and right associative, respectively). <span class="math display">
\begin{aligned}
A \to A \alpha \ |\ \beta &amp;\implies \mathcal L(G) = \{\beta, \beta \alpha, \beta \alpha \alpha, \ldots\}\\
A \to \alpha A \ |\ \beta &amp;\implies \mathcal L(G) = \{\beta, \alpha\beta, \alpha\alpha\beta, \ldots\}
\end{aligned}
</span></p>
<h3 id="if-statements">If statements</h3>
<p>Consider a grammar <span class="math display">
\begin{aligned}
S &amp;\to \textit{IfS} \ |\ \ldots \\ 
\textit{IfS} &amp;\to \text{if } C \text{ then } S \text{ else } S \\
\textit{IfS} &amp;\to \text{if } C \text{ then } S
\end{aligned}
</span> However, this is an ambiguous grammar. Take the case <span class="math inline">\text{if } C_1 \text{ then if } C_2 \text{ then } S_1 \text{ else } S_2</span>. The two interpretations are basically <span class="math display">
\text{if } C_1 \text{ then \{ if } C_2 \text{ then } S_1 \text{ \} else } S_2\\
\text{if } C_1 \text{ then \{ if } C_2 \text{ then } S_1 \text{ else } S_2\ \}
</span> Traditionally, programming languages normally take the second one, matching the <span class="math inline">\text{else}</span> with the closest starting <span class="math inline">\text{if}</span> statement. This ambiguity is called the “dangling else problem”.</p>
<p>Conventionally, we can also avoid the issue by enforcing braces (C-style), indentation (Python), or a terminating keyword <span class="math inline">\text{fi}</span> (ALGOL 68, Bash).</p>
<h2 id="chomsky-hierarchy-of-grammars">Chomsky hierarchy of grammars</h2>
<p>Here, nonterminal symbols are uppercase and terminals are lowercase. Greek letters signify possibly empty sequences of terminals or non-terminals. - <strong>Type 3</strong>: Left (or right) linear grammars: <span class="math inline">A \to \epsilon\ |\ aB\ |\ a</span>, with <span class="math inline">B</span> in the same form. - <strong>Type 2</strong>: Context-free grammars: <span class="math inline">A \to \alpha</span>. - <strong>Type 1</strong>: Context-sensitive grammars: <span class="math inline">\beta A \gamma \to \beta \alpha \gamma</span>. - <strong>Type 0</strong>: Unrestricted grammars: <span class="math inline">\alpha \to \beta</span>, where <span class="math inline">\alpha \ne \epsilon</span>.</p>
<p>Note that each type is a superset of the previous. Type 3 left linear grammars are, in fact, regular expressions. Type 1 is called context-sensitive because we can only replace <span class="math inline">A</span> with <span class="math inline">\alpha</span> when it is surrounded by the appropriate symbols.</p>
<p>There are some correspondences between these types and more familiar conventions: - <strong>Type 3</strong>: finite automaton (state machines), regular expressions, left/right linear grammars. - <strong>Type 2</strong>: pushdown automaton (with a stack), context-free grammar. - <strong>Type 1</strong>: context-sensitive grammar. - <strong>Type 0</strong>: unrestricted grammar, Turing machine equivalent, general computation.</p>
<h2 id="recursive-descent-parsing">Recursive descent parsing</h2>
<p>We will focus on top-down parsing for now, with bottom-up parsing to come later.</p>
<p>We will be using extended BNF (EBNF) to write our grammars. It is always possible to take an ENBF grammar and rewrite it as BNF. It introduces the following syntax: - <span class="math inline">[\ S\ ]</span> is for optionals and is equivalent to <span class="math inline">\textit{OpS} \to S\ |\ \epsilon</span>. - <span class="math inline">\{\ S\ \}</span> is for zero or more repetitions of <span class="math inline">S</span> and is equivalent to <span class="math inline">\textit{RepS}\to(S)\ \textit{RepS}\ |\ \epsilon</span>. - <span class="math inline">(\ S\ )</span> is for precedence grouping.</p>
<h3 id="implementation">Implementation</h3>
<p>We start with terminal symbols, such as identifiers, matching them with <code>tokens.match(Token.T)</code>.</p>
<p>For non-terminal symbols, such as <span class="math inline">\textit{RelCondition}</span>, we will write something like <code>parseRelCondition()</code>.</p>
<p>To parse a sequence of symbols, such as <span class="math inline">S_1S_2\ldots</span>, we will use <code>recog(s1); recog(s2);</code> for some recogniser functions.</p>
<p>For example, to parse <span class="math inline">\textit{Factor}\to\textit{LPAREN RelCondition RPAREN}</span> we will use</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>tokens.<span class="fu">match</span>(Token.<span class="fu">LPAREN</span>);</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">parseRelCondition</span>();</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>tokens.<span class="fu">match</span>(Token.<span class="fu">RPAREN</span>);</span></code></pre></div>
<p>For alternatives, we need to be careful about which alternative to choose. In this grammar, it is always possible to choose the correct alternative by at one token. This is not always the case. For $  |  | , we can match it using</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="dt">void</span> <span class="fu">parseFactor</span>() {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  <span class="kw">if</span> (tokens.<span class="fu">isMatch</span>(Token.<span class="fu">LPAREN</span>)) {</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    tokens.<span class="fu">match</span>(Token.<span class="fu">LPAREN</span>);</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>    <span class="fu">parseRelCondition</span>();</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>    tokens.<span class="fu">match</span>(Token.<span class="fu">RPAREN</span>);</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>  } <span class="kw">else</span> <span class="kw">if</span> (tokens.<span class="fu">isMatch</span>(Token.<span class="fu">NUMBER</span>)) {</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>    tokens.<span class="fu">match</span>(Token.<span class="fu">NUMBER</span>);</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>  } <span class="kw">else</span> <span class="kw">if</span> (tokens.<span class="fu">isMatch</span>(Token.<span class="fu">IDENTIFIER</span>)) {</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>    <span class="fu">parseLValue</span>();</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>  } <span class="kw">else</span> {</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>    <span class="co">// throw new eXcEPtIoN(&quot;yeet&quot;);</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>    <span class="fu">error</span>(<span class="st">&quot;Syntax error&quot;</span>);</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>  }</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a>}</span></code></pre></div>
<p>To parse optionals, such as <span class="math inline">\textit{RelCondition} \to \textit{Exp } [\ \textit{RelOp Exp}\ ]</span>, we can use something like</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="dt">void</span> <span class="fu">parseRelCondition</span>() {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  <span class="fu">parseExp</span>();</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  <span class="kw">if</span> (tokens.<span class="fu">isIn</span>(REL_OPS_SET)) { <span class="co">// because there are multiple RelOps</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>    <span class="fu">parseRelOp</span>();</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>    <span class="fu">parseExp</span>();</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>  }</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>}</span></code></pre></div>
<p>To parse an if statement of the form <span class="math display">
\textit{IfStatement} \to \textit{KW\_IF Condition KW\_THEN Statement }[\textit{ KW\_ELSE Statement }],
</span> we can use</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="dt">void</span> <span class="fu">parseIfStatement</span>() {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  tokens.<span class="fu">match</span>(Token.<span class="fu">KW_IF</span>);</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>  <span class="fu">parseCondition</span>();</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>  tokens.<span class="fu">match</span>(Token.<span class="fu">KW_THEN</span>);</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>  <span class="fu">parseStatement</span>();</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>  <span class="kw">if</span> (tokens.<span class="fu">isMatch</span>(Token.<span class="fu">KW_ELSE</span>)) {</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>    tokens.<span class="fu">match</span>(Token.<span class="fu">KW_ELSE</span>);</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>    <span class="fu">parseStatement</span>();</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>  }</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>}</span></code></pre></div>
<p>We can parse a term of <span class="math inline">\textit{Term} \to \textit{Factor }\{\ (\textit{ TIMES | DIVIDE ) Factor }\}</span> like</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="dt">void</span> <span class="fu">parseTerm</span>() {</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>  <span class="fu">parseFactor</span>();</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>  <span class="kw">while</span> (tokens.<span class="fu">isIn</span>(TERM_OPS_SET)) {</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>    tokens.<span class="fu">match</span>(tokens.<span class="fu">isMatch</span>(Token.<span class="fu">TIMES</span>) ? Token.<span class="fu">TIMES</span> : Token.<span class="fu">DIVIDE</span>);</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>    <span class="co">// we should assert error if token is neither times or divide.</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>    <span class="fu">parseFactor</span>();</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>  }</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>}</span></code></pre></div>
<p>Consider a rule <span class="math inline">\textit{Factor} \to \textit{LPAREN Exp RPAREN }|\ \textit{NUMBER}</span>. We might want it to <em>evaluate</em> a factor as we parse it. We can do that with an extra variable, like</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="dt">int</span> <span class="fu">parseFactor</span>() {</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>  <span class="dt">int</span> result = <span class="bn">0x80808080</span>; <span class="co">// useful useless value.</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>  <span class="kw">if</span> (tokens.<span class="fu">isMatch</span>(Token.<span class="fu">LPAREN</span>)) {</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    tokens.<span class="fu">match</span>(Token.<span class="fu">LPAREN</span>);</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>    result = <span class="fu">parseExp</span>();</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>    tokens.<span class="fu">match</span>(Token.<span class="fu">RPAREN</span>);</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>  } <span class="kw">else</span> <span class="kw">if</span> (tokens.<span class="fu">isMatch</span>(Token.<span class="fu">NUMBER</span>)) {</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>    result = tokens.<span class="fu">getIntValue</span>(); <span class="co">// assumes current token is a number</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>    tokens.<span class="fu">match</span>(Token.<span class="fu">NUMBER</span>); <span class="co">// consume and advance to next token</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>  } <span class="kw">else</span> {</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>    <span class="fu">error</span>(<span class="st">&quot;Syntax error&quot;</span>);</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>  }</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>  <span class="kw">return</span> result;</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>}</span></code></pre></div>
    <p><small>Generated at 7/5/2020, 12:33:39 PM.</small></p>
  </body>
</html>

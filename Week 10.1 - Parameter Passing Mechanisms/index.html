<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    
    <title>Week 10.1 - Parameter Passing Mechanisms</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/light.min.css">
    <!--<link rel="stylesheet" href="https://unpkg.com/mvp.css">-->
    <!--<link rel="stylesheet" href="https://latex.now.sh/style.css">-->
    <style>
        code{white-space: pre-wrap;}
        span.smallcaps{font-variant: small-caps;}
        span.underline{text-decoration: underline;}
        div.column{display: inline-block; vertical-align: top; width: 50%;}
        .katex { font-size: 1.1em; }
    </style>
    <!--<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
    <script>document.addEventListener("DOMContentLoaded", function () {
    var mathElements = document.getElementsByClassName("math");
    var macros = [];
    /*
    const BATCH_SIZE = 100;
    var i = 0;
    while (i < mathElements.length) {
      const start = i;
      setTimeout(() => {
        for (var j = 0; j < BATCH_SIZE; j++) {
          const i = start + j;
          if (i >= mathElements.length) break;

          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }, 0);
      i += BATCH_SIZE;
    }
    */
    
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
      katex.render(texText.data, mathElements[i], {
        displayMode: mathElements[i].classList.contains('display'),
        throwOnError: false,
        macros: macros,
        fleqn: false
      });
    }}
    
    });
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <h1>Week 10.1 - Parameter Passing Mechanisms</h1>

    <!--
-->


<h1 id="week-10.1-parameter-passing-mechanisms">Week 10.1 — Parameter Passing Mechanisms</h1>
<p><strong>Formal parameters</strong> are the parameters used in the declaration of the procedure in its header. The <strong>actual parameters</strong> are the parameters actually passed to a procedure during a call. Formal parameter names are used to access the actual parameters while in a procedure body.</p>
<p>For call-by-value parameters, the actual parameters are evaluated and, if necessary, coerced to the type of the formal parameter.</p>
<p>The values of the actual parameters are loaded onto the stack before the new stack frame is set up. Then, the formal parameters can be accessed just like local variables but with negative offsets.</p>
<p><em>Example:</em></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode pascal"><code class="sourceCode pascal"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">procedure</span> fact(n: int): int =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>    <span class="kw">begin</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>        return <span class="dv">1</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="kw">else</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>        return n*fact(n<span class="dv">-1</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>    <span class="kw">end</span>;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="kw">begin</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>    <span class="kw">write</span> fact(<span class="dv">2</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<p>A function returns a <strong>result</strong> and that result can be used as part of a larger expression. In the stack machine, the result is left on top of the stack after removing all call information. For this reason, space for the result is allocated before the parameters, stack frame, and everything else.</p>
<p>There are a number of parameter passing mechanisms:</p>
<ul>
<li><strong>Call by const</strong> is the same as call by value but the formal parameter is a <em>read only</em> local variable.</li>
<li><strong>Call by value</strong>, as discussed earlier. Assigning to the formal parameter does not change the actual parameter.</li>
<li><strong>Call by result</strong> is where a formal parameter acts as a local variable whose final value is assigned to the actual parameter variable. Here, the actual parameter must be an LValue of some type.</li>
<li><strong>Call by value-result</strong> where a single parameter acts as both a value and result parameter (as discussed above). Think MATLAB.</li>
<li><strong>Call by reference</strong> the formal parameter is actually an address of the actual parameter; all references to the formal parameter affect the actual parameter (immediately). This can be done in C by passing a pointer then interacting via *.</li>
<li><strong>Call by sharing</strong> is just call by value but the value is a reference to an object rather than the object itself. This sounds like Java.</li>
<li><strong>Call by name</strong> is where the actual parameter expression is evaluated every time the formal parameter is accessed (this sounds like a bad idea).</li>
</ul>
<p>More generally, we can pass and return procedures/functions.</p>
<ul>
<li>Passing procedures pass the the address of the procedure as well as the static link for the procedure’s environment, i.e. the static link to be used when calling the procedure.</li>
<li>Returning procedures is a little more complicated. We return the address as well as the static link for the procedure’s environment. This can complicate things because the static link needs to remain valid, so the stack-based allocation of frames is no longer sufficient. Think functional programming and lambdas in Java.</li>
</ul>
<p>In the matrix multiplication example, call by value/result works as expected but call by reference can go astray.</p>
<p>Variable aliasing can occur:</p>
<ul>
<li>Parameter aliasing in languages with call by reference is when the same variable is passed to multiple parameters; two formal parameter names for the same actual parameter variable.</li>
<li>Global variable aliasing is if a global variable passed as a reference parameter.</li>
</ul>
<p>Pointer aliasing:</p>
<ul>
<li>Parameter aliasing in languages with call by sharing (like Java) is where two parameters are aliases for the same reference, called pointer aliasing.</li>
<li>Similarly for global variable aliasing.</li>
</ul>
<h2 id="examples-of-parameters">Examples of parameters</h2>
<p>Here are some examples of each parameter passing type, in C-style syntax as best as possible.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co">// placeholder object we can pass a reference</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="dt">int</span> param; </span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="co">// call by const: param is a read only local variable</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="dt">void</span> function(<span class="dt">const</span> <span class="dt">int</span> x);</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>function(<span class="dv">10</span>);</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a><span class="co">// call by value: param is ordinary local variable</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="dt">void</span> function(<span class="dt">int</span> x);</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>function(<span class="dv">10</span>);</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a><span class="co">// call by result: inside function, param is a local variable.</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a><span class="co">// after function, local variable is stored in actual param.</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a><span class="dt">void</span> function(<span class="dt">int</span>* result) {</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a>    <span class="dt">int</span> x; <span class="co">// do some things.</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a>    *result = x;</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a>}</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a>function(&amp;param);</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a><span class="co">// call by value-result: param is both a value and result</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true"></a><span class="dt">void</span> function(<span class="dt">int</span>* x) {</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true"></a>    *x = *x + <span class="dv">1</span>; <span class="co">// compute result somehow</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true"></a>}</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true"></a>param = <span class="dv">10</span>; <span class="co">// passing value of 10</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true"></a>function(&amp;param); <span class="co">// result now set in param</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true"></a></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true"></a><span class="co">// call by reference: actual param *is* the function&#39;s param</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true"></a><span class="dt">void</span> function(ref <span class="dt">int</span> x) {</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true"></a>    x = <span class="dv">11</span>; <span class="co">// interacts directly with param</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true"></a>}</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true"></a>function(param); <span class="co">// somehow magically passes &quot;param&quot; reference</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true"></a></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true"></a><span class="co">// call by sharing: param is a reference, passed as value</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true"></a><span class="dt">void</span> function(<span class="dt">int</span>* x) {</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true"></a>    *x = *x + <span class="dv">1</span>;</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true"></a>    x = something; <span class="co">// set this value without affecting actual param.</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true"></a>}</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true"></a>function(&amp;param);</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true"></a></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true"></a><span class="co">// call by name: actual param is evaluated every use</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true"></a><span class="pp">#define function(x) ((x) + (x))</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true"></a>function(param + <span class="dv">1</span>);</span></code></pre></div>
    <p><small>Generated at 7/5/2020, 12:22:56 PM.</small></p>
  </body>
</html>

<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    
    <title>Week 10.1 - Parameter Passing Mechanisms</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/light.min.css">
    <!--<link rel="stylesheet" href="https://unpkg.com/mvp.css">-->
    <!--<link rel="stylesheet" href="https://latex.now.sh/style.css">-->
    <style>
        code{white-space: pre-wrap;}
        span.smallcaps{font-variant: small-caps;}
        span.underline{text-decoration: underline;}
        div.column{display: inline-block; vertical-align: top; width: 50%;}
    </style>
    <!--<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
    <script>document.addEventListener("DOMContentLoaded", function () {
    var mathElements = document.getElementsByClassName("math");
    var macros = [];
    /*
    const BATCH_SIZE = 100;
    var i = 0;
    while (i < mathElements.length) {
      const start = i;
      setTimeout(() => {
        for (var j = 0; j < BATCH_SIZE; j++) {
          const i = start + j;
          if (i >= mathElements.length) break;

          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }, 0);
      i += BATCH_SIZE;
    }
    */
    
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
      katex.render(texText.data, mathElements[i], {
        displayMode: mathElements[i].classList.contains('display'),
        throwOnError: false,
        macros: macros,
        fleqn: false
      });
    }}
    
    });
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <h1>Week 10.1 - Parameter Passing Mechanisms</h1>

    <!--
-->


<h1 id="week-10.1-parameter-passing-mechanisms">Week 10.1 — Parameter Passing Mechanisms</h1>
<p><strong>Formal parameters</strong> are the parameters used in the declaration of the procedure in its header. The <strong>actual parameters</strong> are the parameters actually passed to a procedure during a call. Formal parameter names are used to access the actual parameters while in a procedure body.</p>
<p>For call-by-value parameters, the actual parameters are evaluated and, if necessary, coerced to the type of the formal parameter.</p>
<p>The values of the actual parameters are loaded onto the stack before the new stack frame is set up. Then, the formal parameters can be accessed just like local variables but with negative offsets.</p>
<p><em>Example:</em></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode pascal"><code class="sourceCode pascal"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">procedure</span> fact(n: int): int =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>    <span class="kw">begin</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>        return <span class="dv">1</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="kw">else</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>        return n*fact(n<span class="dv">-1</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>    <span class="kw">end</span>;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="kw">begin</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>    <span class="kw">write</span> fact(<span class="dv">2</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<p>A function returns a <strong>result</strong> and that result can be used as part of a larger expression. In the stack machine, the result is left on top of the stack after removing all call information. For this reason, space for the result is allocated before the parameters, stack frame, and everything else.</p>
<p>There are a number of parameter passing mechanisms:</p>
<ul>
<li><p><strong>Call by const</strong> is the same as call by value but the formal parameter is a <em>read only</em> local variable.</p></li>
<li><p><strong>Call by value</strong>, as discussed earlier. Assigning to the formal parameter does not change the actual parameter.</p></li>
<li><p><strong>Call by result</strong> is where a formal parameter acts as a local variable whose final value is assigned to the actual parameter variable. Here, the actual parameter must be an LValue of some type.</p></li>
<li><p><strong>Call by value-result</strong> where a single parameter acts as both a value and result parameter (as discussed above). Think MATLAB.</p></li>
<li><p><strong>Call by reference</strong> the formal parameter is actually an address of the actual parameter; all references to the formal parameter affect the actual parameter (immediately). This can be done in C by passing a pointer then interacting via *.</p></li>
<li><p><strong>Call by sharing</strong> is just call by value but the value is a reference to an object rather than the object itself. This sounds like Java.</p></li>
<li><p><strong>Call by name</strong> is where the actual parameter expression is evaluated every time the formal parameter is accessed (this sounds like a bad idea).</p></li>
</ul>
<p>More generally, we can pass and return procedures/functions.</p>
<ul>
<li>Passing procedures pass the the address of the procedure as well as the static link for the procedure’s environment, i.e. the static link to be used when calling the procedure.</li>
<li>Returning procedures is a little more complicated. We return the address as well as the static link for the procedure’s environment. This can complicate things because the static link needs to remain valid, so the stack-based allocation of frames is no longer sufficient. Think functional programming and lambdas in Java.</li>
</ul>
<p>In the matrix multiplication example, call by value/result works as expected but call by reference can go astray.</p>
<p>Variable aliasing can occur:</p>
<ul>
<li>Parameter aliasing in languages with call by reference is when the same variable is passed to multiple parameters; two formal parameter names for the same actual parameter variable.</li>
<li>Global variable aliasing is if a global variable passed as a reference parameter.</li>
</ul>
<p>Pointer aliasing:</p>
<ul>
<li>Parameter aliasing in languages with call by sharing (like Java) is where two parameters are aliases for the same reference, called pointer aliasing.</li>
<li>Similarly for global variable aliasing.</li>
</ul>
    <p><small>Last updated .</small></p>
  </body>
</html>

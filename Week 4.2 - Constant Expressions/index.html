<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    
    <title>Week 4.2 - Constant Expressions</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/light.min.css">
    <!--<link rel="stylesheet" href="https://unpkg.com/mvp.css">-->
    <!--<link rel="stylesheet" href="https://latex.now.sh/style.css">-->
    <style>
        code{white-space: pre-wrap;}
        span.smallcaps{font-variant: small-caps;}
        span.underline{text-decoration: underline;}
        div.column{display: inline-block; vertical-align: top; width: 50%;}
        .katex { font-size: 1.1em; }
    </style>
    <!--<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
    <script>document.addEventListener("DOMContentLoaded", function () {
    var mathElements = document.getElementsByClassName("math");
    var macros = [];
    /*
    const BATCH_SIZE = 100;
    var i = 0;
    while (i < mathElements.length) {
      const start = i;
      setTimeout(() => {
        for (var j = 0; j < BATCH_SIZE; j++) {
          const i = start + j;
          if (i >= mathElements.length) break;

          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }, 0);
      i += BATCH_SIZE;
    }
    */
    
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
      katex.render(texText.data, mathElements[i], {
        displayMode: mathElements[i].classList.contains('display'),
        throwOnError: false,
        macros: macros,
        fleqn: false
      });
    }}
    
    });
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <h1>Week 4.2 - Constant Expressions</h1>

    <!--
-->


<h1 id="lecture-8-constant-expressions">Lecture 8 — Constant Expressions</h1>
<blockquote>
<p>Assignment 1 deadline has been pushed back to Thursday, 9th April.</p>
</blockquote>
<p>Let’s look at constants. The only operation we can do on constants is negation. They can also refer to other constants, but we need to be careful of circular references. In the compiler, constant expressions have 3 states: unresolved, resolving and resolved.</p>
<pre><code>const A = -27;
      C = -D;
      D = -C;
      E = 5;</code></pre>
<p>A number is initially resolved because it has an obvious value. A negate node can be evaluated by negating its subexpression value. A constant node needs to detect and invalidate circular constants by making use of the “resolving” state. A constant identifier should only ever be evaluated once (I believe).</p>
<p>A similar circular definition can occur with types. They are handled in the same way.</p>
<h2 id="the-interpreter">The Interpreter</h2>
<p>In this course, we’re looking at two different ways of executing programs: an interpreter and code generation (for a stack machine).</p>
<p>It makes use of the visitor pattern, but using values instead of nodes.</p>
<p>For each procedure call, there is a stack frame which contains space for variables (entries), its procedure, and other information. There are various functions to visit different types of nodes, which return Value subclasses.</p>
<ul>
<li>The value returned for a variable is an address, which has a level and offset.</li>
<li>The value of visiting a binary node is an integer value, resulting from the evaluation of the operation. Logical values are internally treated as 1 and 0.</li>
<li>Similarly for a unary node, we evaluate return the result.</li>
<li>A dereference node gets the left-value and evaluates it by locating its containing frame and offset. Unassigned variables are detected by null inside the frame.</li>
<li>Visit a narrow subrange node evaluates the expression, then does a runtime check to ensure the value is within the subrange.</li>
<li>Widen will always succeed so just returns the integer.</li>
<li>Visitng a statement list node just calls ‘accept’ for each statement in the list.</li>
<li>An assignment evaluates the left and right sides. Left should be an address and right should be an integer, then it assigns the variable to the left-value.</li>
<li>Call sets up a new frame for the function’s variables, then executes the function block using ‘accept’. The previous frame is restored after exiting the function.</li>
<li>An if statement evaluates the condition, then calls the appropriate block depending on if it was true or false.</li>
<li>A while node is similar.</li>
</ul>
<h3 id="an-example-of-stack-frames">An example of stack frames</h3>
<pre><code>var x : int;
    y : int;
procedure f() =
    var y : int;
    begin
        y := x;
        if x &gt; 0 then
        begin
            x := x-1;
            call f();
        end
        else
            y := x;
        write y
    end;
begin
    x := 2;
    call f()
end</code></pre>
<p>Let’s look at the stack frame for this (nonsense) program. A stack frame contains a static link and dynamic link, then an array of variable entries.</p>
<p>First, we assign 2 to <span class="math inline">x</span> within the Main frame:</p>
<figure>
<img src="/assets/image-20200325154412125.png" alt="" /><figcaption>image-20200325154412125</figcaption>
</figure>
<p>Then, we construct a new frame for <span class="math inline">f</span>. The static link here is a pointer to the closest program which directly includes it. Here, it will be a pointer up to the main frame. The dynamic link always points to the procedure or main program which called <span class="math inline">f</span>. In this case, it is also main.</p>
<p>We find the value of <span class="math inline">x</span> by looking up the frames, then store that into <span class="math inline">y</span>. Then, we decrement <span class="math inline">x</span> because <span class="math inline">x &gt; 0</span>.</p>
<figure>
<img src="/assets/image-20200325154637816.png" alt="" /><figcaption>image-20200325154637816</figcaption>
</figure>
<p>We construct a new stack frame. The static link will be to main, the dynamic link will be to the first <span class="math inline">f</span> frame.</p>
<p>Then we call <span class="math inline">f</span> again, with similar results. Now, <span class="math inline">x</span> is not <span class="math inline">&gt;0</span> so we assign <span class="math inline">x</span> to <span class="math inline">y</span>, then write out <span class="math inline">y</span> and return.</p>
<figure>
<img src="/assets/image-20200325154851187.png" alt="" /><figcaption>image-20200325154851187</figcaption>
</figure>
<p>When we return, that means we throw away the last frame, then go back and write <span class="math inline">y</span> in the 2nd <span class="math inline">f</span> frame, then go up and write <span class="math inline">y</span> in the 1st frame, then go back to main, then terminate.</p>
    <p><small>Generated at 7/5/2020, 12:33:39 PM.</small></p>
  </body>
</html>
